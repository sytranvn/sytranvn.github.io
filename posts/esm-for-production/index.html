<!doctype html><html lang=en><head><title>ESM for Production ¬∑ sytranvn.dev</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Sy Tran"><meta name=description content="The JavaScript ecosystem is quickly moving toward publishing ECMAScript modules (ESM) instead of CommonJS modules. Is it ready for production?"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="ESM for Production"><meta name=twitter:description content="The JavaScript ecosystem is quickly moving toward publishing ECMAScript modules (ESM) instead of CommonJS modules. Is it ready for production?"><meta property="og:url" content="https://sytranvn.dev/posts/esm-for-production/"><meta property="og:site_name" content="sytranvn.dev"><meta property="og:title" content="ESM for Production"><meta property="og:description" content="The JavaScript ecosystem is quickly moving toward publishing ECMAScript modules (ESM) instead of CommonJS modules. Is it ready for production?"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-01T10:01:30+07:00"><meta property="article:modified_time" content="2023-09-01T10:01:30+07:00"><link rel=canonical href=https://sytranvn.dev/posts/esm-for-production/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.ebdf1a5dca6a69142e979b32668c69f2a95448b145a168104c5808b14d2b75b0.css integrity="sha256-698aXcpqaRQul5syZoxp8qlUSLFFoWgQTFgIsU0rdbA=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/custom.min.36eb58d02db7d3831e8ec30480fa209ae93627f039c1c577e7fdeece45784a20.css integrity="sha256-NutY0C2304MejsMEgPogmuk2J/A5wcV35/3uzkV4SiA=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://sytranvn.dev/>sytranvn.dev
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/now/>Now</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/projects/>Projects</a></li><li class=navigation-item><a class=navigation-link href=/i-heart-oss/>I ‚ù§Ô∏è OSS</a></li><li class=navigation-item><a class=navigation-link href=/accomplishments/>Accomplishments</a></li><li class=navigation-item><a class=navigation-link href=/resume.pdf>Resume</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class=navigation-item><a href=/vi/>üáªüá≥</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://sytranvn.dev/posts/esm-for-production/>ESM for Production</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2023-09-01T10:01:30+07:00>September 1, 2023
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
6-minute read</span></div></div><script id=diffblog-plugin-script async src=https://diff.blog/static/js/diffblog_plugin_v1.js></script><script>document.getElementById("diffblog-plugin-script").addEventListener("load",function(){DiffBlog("4at5qx7n0j5yhd86rqu6gyotkgn4o17hu8wn6xis54lwd692ez")})</script></header><div class=post-content>The JavaScript ecosystem is quickly moving toward publishing ECMAScript modules (ESM) instead of CommonJS modules. Is it ready for production?<p>The JavaScript ecosystem is quickly moving toward publishing ECMAScript (ES) modules (ESM) instead of CommonJS modules. To keep up with new JS changes, I often learn and play with the new ones in my side projects. But the real question is are they ready for production yet?</p><h2 id=about-my-last-big-production-ready-application>About my last big production ready application
<a class=heading-link href=#about-my-last-big-production-ready-application><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>In my former company, I developed an application using NodeJS + GraphQL as backend for frontent (BFF) and use React
for rendering UI. They are all written in Typescript. We built it from beginning but on top of a template which is defined awhile back by the org. It started as smooth as we hoped it to but the more we developed, the worse DX became.</p><p><strong>I have latest version of Node, can I use this ESNext feature? NO!! YOU DON&rsquo;T</strong><br>This is my biggest regret when I didn&rsquo;t look into the template configuration at all, assuming they are configured
by the pros, and they know better than I do. That assumption is true, but I didn&rsquo;t expect that they built that template
a few years ago. But Javascript has a &ldquo;jet engine&rdquo; (JIT), that can travel at speed of light üò± When you use node 16 and write <code>array.flatMap</code>, <code>string.replaceAll</code>, TS will yell at you, that thing does not exists in current targeted version. Even though that syntax is perfectly valid at runtime, and you&rsquo;re sure about that, you can&rsquo;t touch it&mldr;</p><p>You might argue that I can still change the <code>tsconfig</code> target to add new ES features to my project. Of course I thought that too. But it was easier thought than done. You can&rsquo;t just edit a json file and walk away. Newer targets require higher major TS version. And I had nightmare during that time because I couldn&rsquo;t handle the errors pop up all over the places. Then the product needs more features, I shouldn&rsquo;t holding on it for too long. So I decided to declare a compatible type to be able to use it and turn away.<br><em>Fun fact: while I&rsquo;m writing this post and opening <a href=https://github.com/DefinitelyTyped/DefinitelyTyped/issues/60924 class=external-link target=_blank rel=noopener>node@18.x.x version not fetch global api</a> issue in a browser tab. There are 2 more comments and 1 pull request added to it</em> ü§£</p><p>Of course this could be avoided in the beginning if we configured typescript to match the node version we intend to use. But we would introduce a different variant from organization standard, and in my former company, we love standard, stability, predictability (that&rsquo;s why they built a project template with TS in the first place). Though, upgrading the template to newer TS version is an other nightmare.</p><p>Of course TS is very useful when you don&rsquo;t know what your teammate wrote in the other component last week, and you don&rsquo;t want to re-read their code to use it probably.</p><h2 id=but-without-types-code-editor-cant-do-static-analysis-and-autocomplete>But without types, code editor can&rsquo;t do static analysis and autocomplete
<a class=heading-link href=#but-without-types-code-editor-cant-do-static-analysis-and-autocomplete><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>This point is valid. Without type definitions, code editor can&rsquo;t be smart enough to analyze our code. Function arguments can be of any types, so it can&rsquo;t suggest you what methods
you can call on an object. But that problem has been solved long before TS is a thing. We had JSDocs for the rescue the whole time. If you don&rsquo;t mind writing type definitions with
TS, I believe it feel the same writing JSDocs typedefs. And it doesn&rsquo;t require any other tools added to you project. And JSDocs is JS in mind so it doesn&rsquo;t introduce new concepts that
does not belong to Javascript like TS does. Everything you write can simply run anywhere.</p><h2 id=hello-webpack-my-old-friend>Hello Webpack my old friend
<a class=heading-link href=#hello-webpack-my-old-friend><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>CommonJS was a solution, but not an official ES feature for modularization JS code. Node and other server-side runtimes adopted it and quickly became a standard to write JS back then. Then modules spec was proposed to ES with <code>import, export</code> keywords. Browsers and server runtime now can use the same syntax to import modules, can&rsquo;t they?
The answer is NO! Not until it pass stages of reviews and is added to the spec. But community like it. So we start using it without permission.
With the help of Babel and Webpack, developers can write code in the style they like. And ship it in a different format that no one ever look at. They are used in almost every projects. Hence, when I start a new project, I google some Balbel + Webpack configuration, put it in my project, write some code, try adding some configurations if my code need, forget about the configuration, and repeat all of these steps again for next projects.
Repeating dummy steps without any takeaway make me also resist using Babel+Webpack too (sure they are still useful for frontend application for performance reasons, and libraries that need to support different runtimes).
If they are needed for UI app, let the library, framework handle it, <code>create-react-app</code>, <code>vue create</code>, <code>sveltekit</code>&mldr; Those who introduce new weird syntaxes have to carry the burden they made not us. Or because we chose them instead of writing vanilla JS, it&rsquo;s on us too, lol?<br>I use libraries, I don&rsquo;t write libraries, so not until then<br>But for server side, let&rsquo;s answer a few questions.</p><ul><li>Does it help improving application startup time?
Maybe, maybe not (JIT compiler is the one decides how your code is parsed and executed at runtime, not TS or Babel).</li><li>Does it allow you to write new syntax and run on any server runtime?
Why do you random node version on server you control? Just pick latest LTS version.</li><li>Does it improve performance? I don&rsquo;t thing so, or even worse, they replace a native API with a polyfill which is less performance.</li><li>If you have an API bug, are you sure the code you wrote and run on local is exactly the same as your server is running?</li><li>Does it reduce bundle size?<br>If your final distribution include your code and built code, it is doubled in size.<br>If you build your code and only distribute built code, you double the build time.<br>If you don&rsquo;t use Babel and Webpack, you don&rsquo;t double anything.</li></ul><p>If ESM is so good, why don&rsquo;t we start using it for production application?<br>There are a few downsides of ESM at the moment. We often include bunch of libraries in our project, which includes more dependencies. Those libraries might not distributed a ESM compatible variant.<br>Some logging, tracing tools are heavily implemented on top of CommonJS features like opentelemetry. We developer can wait to add it to our code, but production application can&rsquo;t wait to spill out bugs and by that time you start to regret not having a tracing agent. Testing frameworks too.</p><p>If you don&rsquo;t use those tools, why not try native ESM? Just remove TS, Babel, Webpack dependencies, add <code>"type": "module"</code> to your <code>package.json</code>. And the most hard working part, adding <code>.js</code> extension to all your relative imports. Make sure you use Node version 16 or higher. You can start rolling with ESM.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>¬©
2021 -
2025
Sy Tran
¬∑
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>