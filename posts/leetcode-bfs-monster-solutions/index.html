<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
Leetcode Bfs Monster Solutions · sytranvn.dev
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Sy Tran">
<meta name="description" content="
  42 ms
  
    
    Link to heading
  

class Solution {
private:

    struct P {
        int y;
        int x;
    };

    struct BfsRunner {
        const int end;
        vector&lt;vector&lt;int&gt;&gt;&amp; grid;
        const int mark;
        const int other;
        queue&lt;P&gt; queue;

        BfsRunner(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int y, int x, int mark, int other): grid(grid), end(grid.size() - 1), mark(mark), other(other), queue() {
            queue.push({ y, x });
            grid[y][x] = mark;
        }

        bool step() {
            for (int c = queue.size(); c &gt; 0; --c) {
                const auto p = queue.front();
                queue.pop();
                const int yMin = max(0, p.y - 1), yMax = min(end, p.y &#43; 1),
                        xMin = max(0, p.x - 1), xMax = min(end, p.x &#43; 1);
                for (int y = yMin; y &lt;= yMax; &#43;&#43;y) {
                    for (int x = xMin; x &lt;= xMax; &#43;&#43;x) {
                        if (grid[y][x] != 0) {
                            if (grid[y][x] == other) {
                                return true;
                            }
                            continue;
                        }
                        queue.push({ y, x });
                        grid[y][x] = mark;
                    }
                }
            }
            return false;
        }

        bool isRunning() {
            return !queue.empty();
        }
    };

    static int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        vector&lt;vector&lt;char&gt;&gt; visited(grid.size(), vector&lt;char&gt;(grid.size(), 0));
        BfsRunner fromStart(grid, 0, 0, 2, 3);
        BfsRunner fromEnd(grid, grid.size() - 1, grid.size() - 1, 3, 2);
        int steps = 1;
        while (fromStart.isRunning() &amp;&amp; fromEnd.isRunning()) {
            &#43;&#43;steps;
            if (fromStart.step()) {
                return steps;
            }
            &#43;&#43;steps;
            if (fromEnd.step()) {
                return steps;
            }
        }
        return -1;
    }
public:
    int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        if (grid[0][0] != 0 || grid[grid.size() - 1][grid.size() - 1] != 0) {
            return -1;
        }
        if (grid.size() == 1) {
            return 1;
        }
        return bfs(grid);
    }
};

  Fastest 38ms
  
    
    Link to heading
  

#pragma GCC optimize(&#34;Ofast&#34;,&#34;inline&#34;,&#34;-ffast-math&#34;)
#pragma GCC target(&#34;avx,mmx,sse2,sse3,sse4&#34;)
class Solution {
    int sz;
    struct Co{
        int8_t x;
        int8_t y;
        Co operator&#43;(const Co&amp; other){
            return Co{int8_t(x&#43;other.x),int8_t(y&#43;other.y)};
        }
    };
    int checkCo(Co co,const vector&lt;vector&lt;int&gt;&gt;&amp; grid){
        if(co.x&lt;0||co.x&gt;=sz||co.y&lt;0||co.y&gt;=sz) return 1;
        else return grid[co.x][co.y];
    }
    const Co dir[8]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};
    queue&lt;Co&gt; q1,q2;
    int l1,l2;
    int processQ1(queue&lt;Co&gt;&amp; q,vector&lt;vector&lt;int&gt;&gt;&amp; grid){
        int qsz=q.size();
        while(qsz--){
            auto cur=q.front();
            q.pop();
            for(int i=0;i&lt;8;&#43;&#43;i){
                auto nxt=cur&#43;dir[i];
                auto v=checkCo(nxt,grid);
                if(v&gt;1) return -l1&#43;v-2;//change in Q2
                if(v==0){q.emplace(nxt);grid[nxt.x][nxt.y]=l1;}//change in Q2
            }
        }
        l1--;//change in Q2
        return 0;
    }
    int processQ2(queue&lt;Co&gt;&amp; q,vector&lt;vector&lt;int&gt;&gt;&amp; grid){
        int qsz=q.size();
        while(qsz--){
            auto cur=q.front();
            q.pop();
            for(int i=0;i&lt;8;&#43;&#43;i){
                auto nxt=cur&#43;dir[i];
                auto v=checkCo(nxt,grid);
                if(v&lt;0) return l2-2-v;//change in Q2
                if(v==0){q.emplace(nxt);grid[nxt.x][nxt.y]=l2;}//change in Q2
            }
        }
        l2&#43;&#43;;//change in Q2
        return 0;
    }
public:
    int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        static auto _=[](){ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);return 0;}();
        sz=grid.size();
        if(grid[0][0]||grid[sz-1][sz-1]) return -1;
        if(sz==1) return 1;
        grid[0][0]=-1;grid[sz-1][sz-1]=2;
        l1=-2;l2=3;
        q1.emplace(Co{0,0});q2.emplace(Co{int8_t(sz-1),int8_t(sz-1)});
        while(q1.size()&amp;&amp;q2.size()){
            int r=q1.size()&lt;q2.size()?processQ1(q1,grid):processQ2(q2,grid);
            if(r) return r;
        }
        return -1;
    }
};
">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode Bfs Monster Solutions">
  <meta name="twitter:description" content="42 ms Link to heading class Solution { private: struct P { int y; int x; }; struct BfsRunner { const int end; vector&lt;vector&lt;int&gt;&gt;&amp; grid; const int mark; const int other; queue&lt;P&gt; queue; BfsRunner(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int y, int x, int mark, int other): grid(grid), end(grid.size() - 1), mark(mark), other(other), queue() { queue.push({ y, x }); grid[y][x] = mark; } bool step() { for (int c = queue.size(); c &gt; 0; --c) { const auto p = queue.front(); queue.pop(); const int yMin = max(0, p.y - 1), yMax = min(end, p.y &#43; 1), xMin = max(0, p.x - 1), xMax = min(end, p.x &#43; 1); for (int y = yMin; y &lt;= yMax; &#43;&#43;y) { for (int x = xMin; x &lt;= xMax; &#43;&#43;x) { if (grid[y][x] != 0) { if (grid[y][x] == other) { return true; } continue; } queue.push({ y, x }); grid[y][x] = mark; } } } return false; } bool isRunning() { return !queue.empty(); } }; static int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;vector&lt;char&gt;&gt; visited(grid.size(), vector&lt;char&gt;(grid.size(), 0)); BfsRunner fromStart(grid, 0, 0, 2, 3); BfsRunner fromEnd(grid, grid.size() - 1, grid.size() - 1, 3, 2); int steps = 1; while (fromStart.isRunning() &amp;&amp; fromEnd.isRunning()) { &#43;&#43;steps; if (fromStart.step()) { return steps; } &#43;&#43;steps; if (fromEnd.step()) { return steps; } } return -1; } public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if (grid[0][0] != 0 || grid[grid.size() - 1][grid.size() - 1] != 0) { return -1; } if (grid.size() == 1) { return 1; } return bfs(grid); } }; Fastest 38ms Link to heading #pragma GCC optimize(&#34;Ofast&#34;,&#34;inline&#34;,&#34;-ffast-math&#34;) #pragma GCC target(&#34;avx,mmx,sse2,sse3,sse4&#34;) class Solution { int sz; struct Co{ int8_t x; int8_t y; Co operator&#43;(const Co&amp; other){ return Co{int8_t(x&#43;other.x),int8_t(y&#43;other.y)}; } }; int checkCo(Co co,const vector&lt;vector&lt;int&gt;&gt;&amp; grid){ if(co.x&lt;0||co.x&gt;=sz||co.y&lt;0||co.y&gt;=sz) return 1; else return grid[co.x][co.y]; } const Co dir[8]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}}; queue&lt;Co&gt; q1,q2; int l1,l2; int processQ1(queue&lt;Co&gt;&amp; q,vector&lt;vector&lt;int&gt;&gt;&amp; grid){ int qsz=q.size(); while(qsz--){ auto cur=q.front(); q.pop(); for(int i=0;i&lt;8;&#43;&#43;i){ auto nxt=cur&#43;dir[i]; auto v=checkCo(nxt,grid); if(v&gt;1) return -l1&#43;v-2;//change in Q2 if(v==0){q.emplace(nxt);grid[nxt.x][nxt.y]=l1;}//change in Q2 } } l1--;//change in Q2 return 0; } int processQ2(queue&lt;Co&gt;&amp; q,vector&lt;vector&lt;int&gt;&gt;&amp; grid){ int qsz=q.size(); while(qsz--){ auto cur=q.front(); q.pop(); for(int i=0;i&lt;8;&#43;&#43;i){ auto nxt=cur&#43;dir[i]; auto v=checkCo(nxt,grid); if(v&lt;0) return l2-2-v;//change in Q2 if(v==0){q.emplace(nxt);grid[nxt.x][nxt.y]=l2;}//change in Q2 } } l2&#43;&#43;;//change in Q2 return 0; } public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { static auto _=[](){ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);return 0;}(); sz=grid.size(); if(grid[0][0]||grid[sz-1][sz-1]) return -1; if(sz==1) return 1; grid[0][0]=-1;grid[sz-1][sz-1]=2; l1=-2;l2=3; q1.emplace(Co{0,0});q2.emplace(Co{int8_t(sz-1),int8_t(sz-1)}); while(q1.size()&amp;&amp;q2.size()){ int r=q1.size()&lt;q2.size()?processQ1(q1,grid):processQ2(q2,grid); if(r) return r; } return -1; } };">

<meta property="og:url" content="http://localhost:1313/posts/leetcode-bfs-monster-solutions/">
  <meta property="og:site_name" content="sytranvn.dev">
  <meta property="og:title" content="Leetcode Bfs Monster Solutions">
  <meta property="og:description" content="42 ms Link to heading class Solution { private: struct P { int y; int x; }; struct BfsRunner { const int end; vector&lt;vector&lt;int&gt;&gt;&amp; grid; const int mark; const int other; queue&lt;P&gt; queue; BfsRunner(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int y, int x, int mark, int other): grid(grid), end(grid.size() - 1), mark(mark), other(other), queue() { queue.push({ y, x }); grid[y][x] = mark; } bool step() { for (int c = queue.size(); c &gt; 0; --c) { const auto p = queue.front(); queue.pop(); const int yMin = max(0, p.y - 1), yMax = min(end, p.y &#43; 1), xMin = max(0, p.x - 1), xMax = min(end, p.x &#43; 1); for (int y = yMin; y &lt;= yMax; &#43;&#43;y) { for (int x = xMin; x &lt;= xMax; &#43;&#43;x) { if (grid[y][x] != 0) { if (grid[y][x] == other) { return true; } continue; } queue.push({ y, x }); grid[y][x] = mark; } } } return false; } bool isRunning() { return !queue.empty(); } }; static int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;vector&lt;char&gt;&gt; visited(grid.size(), vector&lt;char&gt;(grid.size(), 0)); BfsRunner fromStart(grid, 0, 0, 2, 3); BfsRunner fromEnd(grid, grid.size() - 1, grid.size() - 1, 3, 2); int steps = 1; while (fromStart.isRunning() &amp;&amp; fromEnd.isRunning()) { &#43;&#43;steps; if (fromStart.step()) { return steps; } &#43;&#43;steps; if (fromEnd.step()) { return steps; } } return -1; } public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if (grid[0][0] != 0 || grid[grid.size() - 1][grid.size() - 1] != 0) { return -1; } if (grid.size() == 1) { return 1; } return bfs(grid); } }; Fastest 38ms Link to heading #pragma GCC optimize(&#34;Ofast&#34;,&#34;inline&#34;,&#34;-ffast-math&#34;) #pragma GCC target(&#34;avx,mmx,sse2,sse3,sse4&#34;) class Solution { int sz; struct Co{ int8_t x; int8_t y; Co operator&#43;(const Co&amp; other){ return Co{int8_t(x&#43;other.x),int8_t(y&#43;other.y)}; } }; int checkCo(Co co,const vector&lt;vector&lt;int&gt;&gt;&amp; grid){ if(co.x&lt;0||co.x&gt;=sz||co.y&lt;0||co.y&gt;=sz) return 1; else return grid[co.x][co.y]; } const Co dir[8]={{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}}; queue&lt;Co&gt; q1,q2; int l1,l2; int processQ1(queue&lt;Co&gt;&amp; q,vector&lt;vector&lt;int&gt;&gt;&amp; grid){ int qsz=q.size(); while(qsz--){ auto cur=q.front(); q.pop(); for(int i=0;i&lt;8;&#43;&#43;i){ auto nxt=cur&#43;dir[i]; auto v=checkCo(nxt,grid); if(v&gt;1) return -l1&#43;v-2;//change in Q2 if(v==0){q.emplace(nxt);grid[nxt.x][nxt.y]=l1;}//change in Q2 } } l1--;//change in Q2 return 0; } int processQ2(queue&lt;Co&gt;&amp; q,vector&lt;vector&lt;int&gt;&gt;&amp; grid){ int qsz=q.size(); while(qsz--){ auto cur=q.front(); q.pop(); for(int i=0;i&lt;8;&#43;&#43;i){ auto nxt=cur&#43;dir[i]; auto v=checkCo(nxt,grid); if(v&lt;0) return l2-2-v;//change in Q2 if(v==0){q.emplace(nxt);grid[nxt.x][nxt.y]=l2;}//change in Q2 } } l2&#43;&#43;;//change in Q2 return 0; } public: int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { static auto _=[](){ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);return 0;}(); sz=grid.size(); if(grid[0][0]||grid[sz-1][sz-1]) return -1; if(sz==1) return 1; grid[0][0]=-1;grid[sz-1][sz-1]=2; l1=-2;l2=3; q1.emplace(Co{0,0});q2.emplace(Co{int8_t(sz-1),int8_t(sz-1)}); while(q1.size()&amp;&amp;q2.size()){ int r=q1.size()&lt;q2.size()?processQ1(q1,grid):processQ2(q2,grid); if(r) return r; } return -1; } };">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-06-12T11:36:29+07:00">
    <meta property="article:modified_time" content="2023-06-12T11:36:29+07:00">
    <meta property="article:tag" content="TBD">




<link rel="canonical" href="http://localhost:1313/posts/leetcode-bfs-monster-solutions/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.css" media="screen">
  



 
  
    
    <link rel="stylesheet" href="/css/custom.css" media="screen">
  





<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-dark">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      sytranvn.dev
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/now/">Now</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/projects/">Projects</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/i-heart-oss/">I ❤️ OSS</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/accomplishments/">Accomplishments</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/resume.pdf">Resume</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
<section class="container post">
  <article>
    <header>
      <div class="post-title">
        <h1 class="title">
          <a class="title-link" href="http://localhost:1313/posts/leetcode-bfs-monster-solutions/">
            Leetcode Bfs Monster Solutions
          </a>
        </h1>
      </div>
      <div class="post-meta">
        <div class="date">
          <span class="posted-on">
            <i class="fa-solid fa-calendar" aria-hidden="true"></i>
            <time datetime=" 2023-06-12T11:36:29&#43;07:00">
              June 12, 2023
            </time>
          </span>
          <span class="reading-time">
            <i class="fa-solid fa-clock" aria-hidden="true"></i>
            2-minute read
          </span>
        </div>
        
        <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/tbd/">TBD</a></div>

        <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/tbd/">TBD</a>
    </span></div>

      </div>
    </header>

    <div class="post-content">
      
      
      <h1 id="42-ms">
  42 ms
  <a class="heading-link" href="#42-ms">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">P</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BfsRunner</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> end;
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> mark;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> other;
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span>P<span style="color:#f92672">&gt;</span> queue;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        BfsRunner(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid, <span style="color:#66d9ef">int</span> y, <span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> mark, <span style="color:#66d9ef">int</span> other)<span style="color:#f92672">:</span> grid(grid), end(grid.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), mark(mark), other(other), queue() {
</span></span><span style="display:flex;"><span>            queue.push({ y, x });
</span></span><span style="display:flex;"><span>            grid[y][x] <span style="color:#f92672">=</span> mark;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">step</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> queue.size(); c <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#f92672">--</span>c) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span> p <span style="color:#f92672">=</span> queue.front();
</span></span><span style="display:flex;"><span>                queue.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> yMin <span style="color:#f92672">=</span> max(<span style="color:#ae81ff">0</span>, p.y <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), yMax <span style="color:#f92672">=</span> min(end, p.y <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>),
</span></span><span style="display:flex;"><span>                        xMin <span style="color:#f92672">=</span> max(<span style="color:#ae81ff">0</span>, p.x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), xMax <span style="color:#f92672">=</span> min(end, p.x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> yMin; y <span style="color:#f92672">&lt;=</span> yMax; <span style="color:#f92672">++</span>y) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> xMin; x <span style="color:#f92672">&lt;=</span> xMax; <span style="color:#f92672">++</span>x) {
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (grid[y][x] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">if</span> (grid[y][x] <span style="color:#f92672">==</span> other) {
</span></span><span style="display:flex;"><span>                                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>                            }
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        queue.push({ y, x });
</span></span><span style="display:flex;"><span>                        grid[y][x] <span style="color:#f92672">=</span> mark;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">isRunning</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>queue.empty();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bfs</span>(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;&gt;</span> visited(grid.size(), vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span>(grid.size(), <span style="color:#ae81ff">0</span>));
</span></span><span style="display:flex;"><span>        BfsRunner fromStart(grid, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>        BfsRunner fromEnd(grid, grid.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, grid.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> steps <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (fromStart.isRunning() <span style="color:#f92672">&amp;&amp;</span> fromEnd.isRunning()) {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">++</span>steps;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (fromStart.step()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> steps;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">++</span>steps;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (fromEnd.step()) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> steps;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> shortestPathBinaryMatrix(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (grid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> grid[grid.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][grid.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (grid.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bfs</span>(grid);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="fastest-38ms">
  Fastest 38ms
  <a class="heading-link" href="#fastest-38ms">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#pragma GCC optimize(&#34;Ofast&#34;,&#34;inline&#34;,&#34;-ffast-math&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#pragma GCC target(&#34;avx,mmx,sse2,sse3,sse4&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sz;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Co</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int8_t</span> x;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int8_t</span> y;
</span></span><span style="display:flex;"><span>        Co <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span>(<span style="color:#66d9ef">const</span> Co<span style="color:#f92672">&amp;</span> other){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Co{<span style="color:#66d9ef">int8_t</span>(x<span style="color:#f92672">+</span>other.x),<span style="color:#66d9ef">int8_t</span>(y<span style="color:#f92672">+</span>other.y)};
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">checkCo</span>(Co co,<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(co.x<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>co.x<span style="color:#f92672">&gt;=</span>sz<span style="color:#f92672">||</span>co.y<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>co.y<span style="color:#f92672">&gt;=</span>sz) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> grid[co.x][co.y];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> Co dir[<span style="color:#ae81ff">8</span>]<span style="color:#f92672">=</span>{{<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>},{<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>},{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>},{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>},{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>},{<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>},{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>},{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}};
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span>Co<span style="color:#f92672">&gt;</span> q1,q2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> l1,l2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">processQ1</span>(queue<span style="color:#f92672">&lt;</span>Co<span style="color:#f92672">&gt;&amp;</span> q,vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> qsz<span style="color:#f92672">=</span>q.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(qsz<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> cur<span style="color:#f92672">=</span>q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span>;<span style="color:#f92672">++</span>i){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> nxt<span style="color:#f92672">=</span>cur<span style="color:#f92672">+</span>dir[i];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> v<span style="color:#f92672">=</span>checkCo(nxt,grid);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>l1<span style="color:#f92672">+</span>v<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;<span style="color:#75715e">//change in Q2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){q.emplace(nxt);grid[nxt.x][nxt.y]<span style="color:#f92672">=</span>l1;}<span style="color:#75715e">//change in Q2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        l1<span style="color:#f92672">--</span>;<span style="color:#75715e">//change in Q2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">processQ2</span>(queue<span style="color:#f92672">&lt;</span>Co<span style="color:#f92672">&gt;&amp;</span> q,vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> qsz<span style="color:#f92672">=</span>q.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(qsz<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> cur<span style="color:#f92672">=</span>q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span>;<span style="color:#f92672">++</span>i){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> nxt<span style="color:#f92672">=</span>cur<span style="color:#f92672">+</span>dir[i];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">auto</span> v<span style="color:#f92672">=</span>checkCo(nxt,grid);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> l2<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span>v;<span style="color:#75715e">//change in Q2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(v<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>){q.emplace(nxt);grid[nxt.x][nxt.y]<span style="color:#f92672">=</span>l2;}<span style="color:#75715e">//change in Q2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        l2<span style="color:#f92672">++</span>;<span style="color:#75715e">//change in Q2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> shortestPathBinaryMatrix(vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">auto</span> _<span style="color:#f92672">=</span>[](){ios_base<span style="color:#f92672">::</span>sync_with_stdio(false);cin.tie(<span style="color:#ae81ff">0</span>);cout.tie(<span style="color:#ae81ff">0</span>);<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;}();
</span></span><span style="display:flex;"><span>        sz<span style="color:#f92672">=</span>grid.size();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(grid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">||</span>grid[sz<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][sz<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(sz<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        grid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;grid[sz<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][sz<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        l1<span style="color:#f92672">=-</span><span style="color:#ae81ff">2</span>;l2<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>        q1.emplace(Co{<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>});q2.emplace(Co{<span style="color:#66d9ef">int8_t</span>(sz<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>),<span style="color:#66d9ef">int8_t</span>(sz<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)});
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(q1.size()<span style="color:#f92672">&amp;&amp;</span>q2.size()){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span>q1.size()<span style="color:#f92672">&lt;</span>q2.size()<span style="color:#f92672">?</span>processQ1(q1,grid)<span style="color:#f92672">:</span>processQ2(q2,grid);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(r) <span style="color:#66d9ef">return</span> r;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div>
    </div>

    <footer>
      

<section class="see-also">
  
    
    
    
  
</section>


      
      
      
      
      
    </footer>
  </article>

  
</section>

    </div>

    <footer class="footer">
  
  <section class="container">
    ©
    
    2021 -
    
    2025
     Sy Tran 
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a
      href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
