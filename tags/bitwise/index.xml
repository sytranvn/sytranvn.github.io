<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bitwise on sytranvn.dev</title><link>https://sytranvn.dev/tags/bitwise/</link><description>Recent content in Bitwise on sytranvn.dev</description><generator>Hugo</generator><language>en</language><lastBuildDate>Tue, 11 Mar 2025 11:31:49 +0700</lastBuildDate><atom:link href="https://sytranvn.dev/tags/bitwise/index.xml" rel="self" type="application/rss+xml"/><item><title>Is Even or Is Not Even (part 2)</title><link>https://sytranvn.dev/posts/is-even-or-is-not-even-2/</link><pubDate>Tue, 11 Mar 2025 11:31:49 +0700</pubDate><guid>https://sytranvn.dev/posts/is-even-or-is-not-even-2/</guid><description>&lt;p&gt;I was so curious how would JavaScript engine would optimize even check. Would
it use modulo as normal, which is very slow, or it can be smart enough to use
bitwise operator ğŸ¤” . Due to its dynamic behavior, variable can be of any type
and unknown to the compiler until run time.&lt;/p&gt;
&lt;p&gt;First, let&amp;rsquo;s create a simple mod function.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-js" data-lang="js"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;my_mod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nx"&gt;my_mod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we need a way to check how V8 compile our code. Luckily, we can view
bytecodes generated by V8 through node. We can use&lt;/p&gt;</description></item><item><title>Is Even or Is Not Even</title><link>https://sytranvn.dev/posts/is-even-or-is-not-even/</link><pubDate>Fri, 21 Feb 2025 22:29:37 +0700</pubDate><guid>https://sytranvn.dev/posts/is-even-or-is-not-even/</guid><description>&lt;p&gt;However, when I look closely to the code, I realized something wasn&amp;rsquo;t right. I
can&amp;rsquo;t find the original post, so this is what I remember. The function is short
so I believe I won&amp;rsquo;t mess anything up.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-ts" data-lang="ts"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;isEven&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;: &lt;span class="kt"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In Javascripts, a number can be an &lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;decimal&lt;/code&gt;, or &lt;code&gt;NaN&lt;/code&gt;, or &lt;code&gt;Inf&lt;/code&gt; or
event &lt;code&gt;BigInt&lt;/code&gt;. But let&amp;rsquo;s assume we only use this for &lt;code&gt;integer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This piece of code is wrong. If we plug a very &amp;ldquo;small&amp;rdquo; negative number in, for
example, &lt;code&gt;-9007199249885170&lt;/code&gt; which is greater than &lt;code&gt;Number.MIN_SAFE_INTEGER = -(2^53-1)&lt;/code&gt; is a safe integer. We get&lt;/p&gt;</description></item></channel></rss>