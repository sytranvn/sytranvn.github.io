# Token
All tokens are defined by a macro `TOKEN_LIST`. It takes a list of 3 macros M all of which satisfy the same signature M(name, string, precedence), where name is the symbolic token name, string is the corresponding syntactic symbol (or NULL, for literals), and precedence is the precedence (or 0).
The parameters are invoked for token categories as follows:
- T: Non-keyword tokens
- K: Keyword tokens
- F: Future (reserved) keyword tokens

```cpp
#ifndef V8_TOKEN_H_
#define V8_TOKEN_H_

#define TOKEN_LIST(T, K, F)                                             \
  /* End of source indicator. */                                        \
  T(EOS, "EOS", 0)                                                      \
                                                                        \
  /* Punctuators (ECMA-262, section 7.7, page 15). */                   \
  T(LPAREN, "(", 0)                                                     \
  T(RPAREN, ")", 0)                                                     \
  T(LBRACK, "[", 0)                                                     \
  T(RBRACK, "]", 0)                                                     \
  /* some more tokens, and keywords */
  K(INSTANCEOF, "instanceof", 10)                                       \
  K(IN, "in", 10)                                                       \
  /* and future reserved words */
  /* Future reserved words (ECMA-262, section 7.5.3, page 14). */       \
  F(ABSTRACT, "abstract", 0)                                            \
  F(BOOLEAN, "boolean", 0)
#endif  // V8_TOKEN_H_
```
## Token class
The `Token` class provides static values and methods to work with token list.
```cpp
class Token {
 public:
  // All token values.
#define T(name, string, precedence) name,
  enum Value {
    TOKEN_LIST(T, T, IGNORE_TOKEN)
    NUM_TOKENS
  };
#undef T
```
This combines with `TOKEN_LIST` will give a result of
```cpp
class Token {
 public:

  enum Value {
    EOS, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, ...,
    NUM_TOKENS
  };
```
Conviniently, `NUM_TOKENS` 's value is exact length of `TOKEN_LIST`.
Use `gcc src/token.h -E -D DEBUG` to see the full source code of `Token` header generated by the macro. When debug mode is on, this macro will generate extra information to help debugging. `Name(tok)` will return the string corresponding to the C++ token name (e.g. "LT" for the token LT).
```cpp
#ifdef DEBUG
  static const char* Name(Value tok) {
    ASSERT(0 <= tok && tok < NUM_TOKENS);
    return name_[tok];
  }
#endif
```
But we don't see how precedence is managed yet. Let's take a look into `src/token.cc`.
```cpp
#include "token.h"

#ifdef DEBUG
#define T(name, string, precedence) #name,
const char* Token::name_[NUM_TOKENS] = {
  TOKEN_LIST(T, T, IGNORE_TOKEN)
};
#undef T
#endif

#define T(name, string, precedence) string,
const char* Token::string_[NUM_TOKENS] = {
  TOKEN_LIST(T, T, IGNORE_TOKEN)
};
#undef T

#define T(name, string, precedence) precedence,
int8_t Token::precedence_[NUM_TOKENS] = {
  TOKEN_LIST(T, T, IGNORE_TOKEN)
};
#undef T
```
Here we can see the `Token::name_` is assigned with token names, and `Token::string_` is assigned with actual token string. And `Token::name_` only requires more memory if we are in debug mode.
The precedences defined in `TOKEN_LIST` will be assigned to `Token::precedence_`.

Since token value is a number from `0` to `NUM_TOKENS - 1`, we need a way to quickly convert a token string to corresponding value, and vice versa. To do so, we use a hash table, if a given string does not match any value in hash table, it must be an identifier.
For later version of v8, hash talbe is auto generated by `gperf` to produce a **perfect hash table**.
> If you don't know how it works, find out. If you're not sure if it will work, try it. If it doesn't make sense, play with it until it does. If it's not broken, break it. If it might not be true, find out.
>
> Seth Godin

`Token` class must be initialized once, checking for collisions, and verify the result again.
